{
  "version": 3,
  "file": "electronHttpExecutor.js",
  "sourceRoot": "",
  "sources": [
    "../src/electronHttpExecutor.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import _debug from \"debug\"\nimport { net, session } from \"electron\"\nimport { configureRequestOptions, DownloadOptions, dumpRequestOptions, HttpExecutor } from \"electron-builder-http\"\nimport { CancellationToken } from \"electron-builder-http/out/CancellationToken\"\nimport { ensureDir } from \"fs-extra-p\"\nimport * as path from \"path\"\nimport { parse as parseUrl } from \"url\"\n\nexport const NET_SESSION_NAME = \"electron-updater\"\n\nconst debug = _debug(\"electron-builder\")\n\nexport class ElectronHttpExecutor extends HttpExecutor<Electron.RequestOptions, Electron.ClientRequest> {\n  async download(url: string, destination: string, options: DownloadOptions): Promise<string> {\n    if (options == null || !options.skipDirCreation) {\n      await ensureDir(path.dirname(destination))\n    }\n\n    return await options.cancellationToken.createPromise<string>((resolve, reject, onCancel) => {\n      const parsedUrl = parseUrl(url)\n\n      this.doDownload(configureRequestOptions({\n        protocol: parsedUrl.protocol,\n        hostname: parsedUrl.hostname,\n        path: parsedUrl.path,\n        port: parsedUrl.port ? parseInt(parsedUrl.port, 10) : undefined,\n        headers: options.headers || undefined,\n      }), destination, 0, options, (error: Error) => {\n        if (error == null) {\n          resolve(destination)\n        }\n        else {\n          reject(error)\n        }\n      }, onCancel)\n    })\n  }\n\n  doApiRequest<T>(options: Electron.RequestOptions, cancellationToken: CancellationToken, requestProcessor: (request: Electron.ClientRequest, reject: (error: Error) => void) => void, redirectCount: number = 0): Promise<T> {\n    if (debug.enabled) {\n      debug(`request: ${dumpRequestOptions(options)}`)\n    }\n\n    return cancellationToken.createPromise<T>((resolve, reject, onCancel) => {\n      const request = net.request(options, response => {\n        try {\n          this.handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor)\n        }\n        catch (e) {\n          reject(e)\n        }\n      })\n      this.addTimeOutHandler(request, reject)\n      request.on(\"error\", reject)\n      requestProcessor(request, reject)\n      onCancel(() => request.abort())\n    })\n  }\n\n\n  protected doRequest(options: any, callback: (response: any) => void): any {\n    options.session = session.fromPartition(NET_SESSION_NAME)\n    return net.request(options, callback)\n  }\n}"
  ]
}
