"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PrivateGitHubProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _electron;

function _load_electron() {
    return _electron = require("electron");
}

var _electronBuilderHttp;

function _load_electronBuilderHttp() {
    return _electronBuilderHttp = require("electron-builder-http");
}

var _CancellationToken;

function _load_CancellationToken() {
    return _CancellationToken = require("electron-builder-http/out/CancellationToken");
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = require("js-yaml");
}

var _path = _interopRequireWildcard(require("path"));

var _url;

function _load_url() {
    return _url = require("url");
}

var _api;

function _load_api() {
    return _api = require("./api");
}

var _electronHttpExecutor;

function _load_electronHttpExecutor() {
    return _electronHttpExecutor = require("./electronHttpExecutor");
}

var _GenericProvider;

function _load_GenericProvider() {
    return _GenericProvider = require("./GenericProvider");
}

var _GitHubProvider;

function _load_GitHubProvider() {
    return _GitHubProvider = require("./GitHubProvider");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

class PrivateGitHubProvider extends (_GitHubProvider || _load_GitHubProvider()).BaseGitHubProvider {
    constructor(options, token) {
        super(options, "api.github.com");
        this.token = token;
        this.netSession = (_electron || _load_electron()).session.fromPartition((_electronHttpExecutor || _load_electronHttpExecutor()).NET_SESSION_NAME);
        this.registerHeaderRemovalListener();
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const basePath = _this.basePath;
            const cancellationToken = new (_CancellationToken || _load_CancellationToken()).CancellationToken();
            const channelFile = (0, (_api || _load_api()).getChannelFilename)((0, (_api || _load_api()).getDefaultChannelName)());
            const assets = yield _this.getLatestVersionInfo(basePath, cancellationToken);
            const requestOptions = Object.assign({
                headers: _this.configureHeaders("application/octet-stream"),
                session: _this.netSession
            }, (0, (_url || _load_url()).parse)(assets.find(function (it) {
                return it.name == channelFile;
            }).url));
            let result;
            try {
                result = yield (0, (_electronBuilderHttp || _load_electronBuilderHttp()).request)(requestOptions, cancellationToken);
                if (typeof result === "string") {
                    if ((0, (_api || _load_api()).getCurrentPlatform)() === "darwin") {
                        result = JSON.parse(result);
                    } else {
                        result = (0, (_jsYaml || _load_jsYaml()).safeLoad)(result);
                    }
                }
            } catch (e) {
                if (e instanceof (_electronBuilderHttp || _load_electronBuilderHttp()).HttpError && e.response.statusCode === 404) {
                    throw new Error(`Cannot find ${channelFile} in the latest release artifacts (${(0, (_api || _load_api()).formatUrl)(requestOptions)}): ${e.stack || e.message}`);
                }
                throw e;
            }
            (0, (_GenericProvider || _load_GenericProvider()).validateUpdateInfo)(result);
            if ((0, (_api || _load_api()).getCurrentPlatform)() === "darwin") {
                result.releaseJsonUrl = `${_this.options.protocol || "https"}://${_this.options.host || "api.github.com"}${requestOptions.path}`;
            }
            result.assets = assets;
            return result;
        })();
    }
    registerHeaderRemovalListener() {
        const filter = {
            urls: ["*://*.amazonaws.com/*"]
        };
        this.netSession.webRequest.onBeforeSendHeaders(filter, (details, callback) => {
            if (details.requestHeaders.Authorization != null) {
                delete details.requestHeaders.Authorization;
            }
            callback({ cancel: false, requestHeaders: details.requestHeaders });
        });
    }
    configureHeaders(accept) {
        return Object.assign({
            Accept: accept,
            Authorization: `token ${this.token}`
        }, this.requestHeaders);
    }
    getLatestVersionInfo(basePath, cancellationToken) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const requestOptions = Object.assign({
                path: `${basePath}/latest`,
                headers: _this2.configureHeaders("application/vnd.github.v3+json")
            }, _this2.baseUrl);
            try {
                return (yield (0, (_electronBuilderHttp || _load_electronBuilderHttp()).request)(requestOptions, cancellationToken)).assets;
            } catch (e) {
                throw new Error(`Unable to find latest version on GitHub (${(0, (_api || _load_api()).formatUrl)(requestOptions)}), please ensure a production release exists: ${e.stack || e.message}`);
            }
        })();
    }
    get basePath() {
        return `/repos/${this.options.owner}/${this.options.repo}/releases`;
    }
    getUpdateFile(versionInfo) {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const headers = {
                Accept: "application/octet-stream",
                Authorization: `token ${_this3.token}`
            };
            // space is not supported on GitHub
            if ((0, (_api || _load_api()).getCurrentPlatform)() === "darwin") {
                const info = versionInfo;
                const name = info.url.split("/").pop();
                const assetPath = (0, (_url || _load_url()).parse)(versionInfo.assets.find(function (it) {
                    return it.name == name;
                }).url).path;
                info.url = (0, (_api || _load_api()).formatUrl)(Object.assign({ path: `${assetPath}` }, _this3.baseUrl));
                info.headers = headers;
                return info;
            } else {
                const name = versionInfo.githubArtifactName || _path.posix.basename(versionInfo.path).replace(/ /g, "-");
                return {
                    name: name,
                    url: versionInfo.assets.find(function (it) {
                        return it.name == name;
                    }).url,
                    sha2: versionInfo.sha2,
                    headers: headers,
                    session: _this3.netSession
                };
            }
        })();
    }
}
exports.PrivateGitHubProvider = PrivateGitHubProvider; //# sourceMappingURL=PrivateGitHubProvider.js.map